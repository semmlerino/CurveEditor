# StateManager Signal Architecture Refactor Plan

## Executive Summary

The recent `total_frames_changed` signal bug exposed a systematic architectural gap in StateManager: **properties that affect UI state lack proper signal emission**. This document provides a comprehensive refactor plan to eliminate technical debt and establish clear architectural principles.

## Root Cause Analysis

The `total_frames` bug revealed this anti-pattern:
```python
# set_image_files() implicitly changes total_frames
def set_image_files(self, files: list[str]) -> None:
    self._image_files = files.copy()
    self.total_frames = len(files) if files else 1  # ‚Üê IMPLICIT SETTER
    # No signal for image_files change!
```

**Problem**: When `total_frames` changed without a signal, the timeline UI couldn't sync its range.

**Lesson**: Any property that can be set **implicitly** (as a side effect) AND affects UI MUST emit a signal.

---

## Property Audit

### ‚úÖ Properties WITH Proper Signals (10)

| Property | Signal | Notes |
|----------|--------|-------|
| `current_file` | `file_changed` | ‚úÖ Correct |
| `is_modified` | `modified_changed` | ‚úÖ Correct |
| `current_frame` | `frame_changed` | ‚úÖ Delegated to ApplicationState |
| `total_frames` | `total_frames_changed` | ‚úÖ **FIXED** (Oct 2025) |
| `zoom_level` | `view_state_changed` | ‚úÖ Correct |
| `pan_offset` | `view_state_changed` | ‚úÖ Correct |
| `view_bounds` | `view_state_changed` | ‚úÖ Correct |
| `playback_mode` | `playback_state_changed` | ‚úÖ Correct |
| `active_timeline_point` | `active_timeline_point_changed` | ‚úÖ Correct |
| `selected_points` | `selection_changed` | ‚úÖ Delegated to ApplicationState |

### ‚ö†Ô∏è Properties WITHOUT Signals (11)

| Property | Current State | UI Impact | Priority |
|----------|---------------|-----------|----------|
| `track_data` | Method only, no signal | **HIGH** - Data changes don't notify UI | üî¥ Critical |
| `image_files` | Method only, no signal | **HIGH** - Image loading affects UI | üî¥ Critical |
| `image_directory` | Setter, no signal | **MEDIUM** - Directory changes affect UI | üü° Important |
| `file_format` | Setter, no signal | **LOW** - No UI depends on this | üü¢ Low |
| `can_undo` | Method only, no signal | **HIGH** - Toolbar buttons don't update | üî¥ Critical |
| `can_redo` | Method only, no signal | **HIGH** - Toolbar buttons don't update | üî¥ Critical |
| `current_tool` | Setter, no signal | **MEDIUM** - Toolbar might not sync | üü° Important |
| `smoothing_window_size` | Setter, no signal | **LOW** - UI writes only, no sync needed | üü¢ Low |
| `smoothing_filter_type` | Setter, no signal | **LOW** - UI writes only, no sync needed | üü¢ Low |
| `hover_point` | Setter, **intentionally** no signal | **N/A** - Performance optimization | ‚úÖ Correct |
| `recent_directories` | Method only, no signal | **LOW** - Session state only | üü¢ Low |

### üìä Summary Statistics

- **Total properties**: 21 (excluding computed read-only)
- **With signals**: 10 (48%)
- **Without signals**: 11 (52%)
- **Critical gaps**: 4 (track_data, image_files, can_undo, can_redo)

---

## Architectural Principles

### Principle 1: Signal Requirement Matrix

A property MUST emit a signal if:
1. ‚úÖ The property affects **visible UI elements** (text, buttons, displays)
2. ‚úÖ The property can be set **implicitly** (via side effects)
3. ‚úÖ Multiple components need to **react** to changes
4. ‚úÖ Changes happen **asynchronously** (commands, data loading)

A property MAY skip signals if:
1. ‚úÖ Only written by UI elements (one-way data flow)
2. ‚úÖ Session state with no runtime sync needs
3. ‚úÖ Performance-critical (hover_point exception)
4. ‚úÖ Computed/read-only derived properties

### Principle 2: Implicit Setters are Dangerous

**Anti-pattern:**
```python
def set_image_files(self, files: list[str]) -> None:
    self._image_files = files.copy()
    self.total_frames = len(files)  # ‚Üê Implicit setter
    # Missing: Signal emission!
```

**Correct pattern:**
```python
def set_image_files(self, files: list[str]) -> None:
    self._image_files = files.copy()
    # Emit signal BEFORE implicit side effects
    self.image_files_changed.emit(files)
    # Now the side effect (which emits its own signal)
    self.total_frames = len(files)  # ‚Üê Emits total_frames_changed
```

### Principle 3: Signal Design

**Signal naming convention:**
```
<property_name>_changed  (singular)
```

**Signal parameter:**
- Emit the **new value** (not old/new pair)
- Use specific types, not `object` unless necessary

**Example:**
```python
# Good
data_changed: Signal = Signal(list)  # Emits new data

# Avoid
data_changed: Signal = Signal()  # No context
data_changed: Signal = Signal(object, object)  # old, new - usually unnecessary
```

---

## Refactor Plan

### Phase 1: Critical Gaps (Week 1)

**Priority**: üî¥ **CRITICAL** - Affects core functionality

#### 1.1 Track Data Signal
**File**: `ui/state_manager.py`

**Current**:
```python
def set_track_data(self, data: list[tuple[float, float]], mark_modified: bool = True) -> None:
    self._track_data = data.copy()
    self._has_data = len(data) > 0
    if mark_modified:
        self.is_modified = True
    # NO SIGNAL!
```

**Refactor**:
```python
# Add signal (line 46)
track_data_changed: Signal = Signal(list)  # Emits new track data

def set_track_data(self, data: list[tuple[float, float]], mark_modified: bool = True) -> None:
    if self._track_data != data:
        self._track_data = data.copy()
        self._has_data = len(data) > 0
        self.track_data_changed.emit(self._track_data)  # ‚Üê ADD
        if mark_modified:
            self.is_modified = True
```

**Impact**: Allows UI components to react to data changes (e.g., update statistics, refresh views)

#### 1.2 Image Files Signal
**File**: `ui/state_manager.py`

**Current**:
```python
def set_image_files(self, files: list[str]) -> None:
    self._image_files = files.copy()
    self.total_frames = len(files) if files else 1  # Implicit setter
    # NO SIGNAL!
```

**Refactor**:
```python
# Add signal (line 47)
image_files_changed: Signal = Signal(list)  # Emits new image file list

def set_image_files(self, files: list[str]) -> None:
    if self._image_files != files:
        self._image_files = files.copy()
        self.image_files_changed.emit(self._image_files)  # ‚Üê ADD (before side effect)
        self.total_frames = len(files) if files else 1  # This emits total_frames_changed
```

**Impact**: Allows image viewer to update when image sequence changes

#### 1.3 Undo/Redo State Signals
**File**: `ui/state_manager.py`

**Current**:
```python
def set_history_state(self, position: int, size: int, can_undo: bool, can_redo: bool) -> None:
    self._history_position = position
    self._history_size = size
    self._can_undo = can_undo
    self._can_redo = can_redo
    # NO SIGNALS!
```

**Refactor**:
```python
# Add signals (lines 48-49)
undo_state_changed: Signal = Signal(bool)  # Emits can_undo
redo_state_changed: Signal = Signal(bool)  # Emits can_redo

def set_history_state(self, position: int, size: int, can_undo: bool, can_redo: bool) -> None:
    self._history_position = position
    self._history_size = size

    # Emit signals only if values changed
    if self._can_undo != can_undo:
        self._can_undo = can_undo
        self.undo_state_changed.emit(can_undo)  # ‚Üê ADD

    if self._can_redo != can_redo:
        self._can_redo = can_redo
        self.redo_state_changed.emit(can_redo)  # ‚Üê ADD
```

**Connect signals** in `ui/controllers/signal_connection_manager.py`:
```python
def _connect_signals(self) -> None:
    # ... existing connections ...

    # Connect undo/redo state to toolbar buttons
    _ = self.main_window.state_manager.undo_state_changed.connect(
        lambda enabled: self.main_window.ui.actions.undo.setEnabled(enabled)
    )
    _ = self.main_window.state_manager.redo_state_changed.connect(
        lambda enabled: self.main_window.ui.actions.redo.setEnabled(enabled)
    )
```

**Impact**: Undo/Redo toolbar buttons automatically enable/disable based on state

---

### Phase 2: Important Gaps (Week 2)

**Priority**: üü° **IMPORTANT** - Improves UX consistency

#### 2.1 Image Directory Signal
**File**: `ui/state_manager.py`

**Add signal**:
```python
image_directory_changed: Signal = Signal(str)  # Emits new directory path or ""

@image_directory.setter
def image_directory(self, directory: str | None) -> None:
    if self._image_directory != directory:
        self._image_directory = directory
        self.image_directory_changed.emit(directory or "")  # ‚Üê ADD
```

**Impact**: Status bar or UI could display current image directory

#### 2.2 Current Tool Signal
**File**: `ui/state_manager.py`

**Add signal**:
```python
current_tool_changed: Signal = Signal(str)  # Emits new tool name

@current_tool.setter
def current_tool(self, tool: str) -> None:
    if self._current_tool != tool:
        self._current_tool = tool
        self.current_tool_changed.emit(tool)  # ‚Üê ADD
```

**Impact**: Toolbar buttons can stay in sync if tool changes programmatically

---

### Phase 3: Low Priority (Week 3)

**Priority**: üü¢ **LOW** - Minor improvements

#### 3.1 File Format Signal (Optional)
Only if future UI needs to display format indicator.

#### 3.2 Smoothing Parameters (Skip)
These are **write-only** from UI perspective - no sync needed.

#### 3.3 Session State (Skip)
`recent_directories`, `window_size` are session-only - no runtime sync needed.

---

## Migration Strategy

### Step 1: Add Signals (No Breaking Changes)
Add new signals to StateManager without changing existing behavior. Existing code continues to work.

### Step 2: Connect Signals (Incremental)
Connect new signals in `SignalConnectionManager` one at a time, testing after each connection.

### Step 3: Verify with Tests
Ensure coordinator tests and integration tests pass after each phase.

### Step 4: Document in CLAUDE.md
Update project documentation with new signals and usage patterns.

---

## Testing Strategy

### Unit Tests
For each new signal, add test:
```python
def test_<property>_changed_signal(qtbot):
    state = StateManager()

    with qtbot.waitSignal(state.<property>_changed) as blocker:
        state.<property> = new_value

    assert blocker.args == [new_value]
```

### Integration Tests
Verify UI components respond to signals:
```python
def test_undo_button_updates_with_history(qtbot, main_window):
    # Initially no undo
    assert not main_window.ui.actions.undo.isEnabled()

    # Perform action
    interaction_service.execute_command(command)

    # Button should now be enabled
    assert main_window.ui.actions.undo.isEnabled()
```

---

## Risk Assessment

### Low Risk ‚úÖ
- Adding signals is **non-breaking** (existing code unaffected)
- Incremental connection allows testing at each step
- Can roll back individual connections if issues arise

### Medium Risk ‚ö†Ô∏è
- **Signal storms**: Batch operations might emit too many signals
  - **Mitigation**: Use existing `batch_update()` context manager
- **Performance**: Additional signal overhead
  - **Mitigation**: Signals only emit if value changed (`if old != new`)

### High Risk üî¥
- **None identified** - This is a purely additive refactor

---

## Success Metrics

1. ‚úÖ **Signal Coverage**: 80%+ of UI-affecting properties have signals
2. ‚úÖ **Test Coverage**: All new signals have unit tests
3. ‚úÖ **Zero Regressions**: All 2,278 existing tests pass
4. ‚úÖ **UI Responsiveness**: Buttons/displays auto-update (manual QA)

---

## Timeline

| Phase | Duration | Priority | Effort |
|-------|----------|----------|--------|
| Phase 1 (Critical) | Week 1 | üî¥ High | 4-6 hours |
| Phase 2 (Important) | Week 2 | üü° Medium | 2-3 hours |
| Phase 3 (Low) | Week 3 | üü¢ Low | 1-2 hours |
| **Total** | **3 weeks** | - | **7-11 hours** |

---

## Future Considerations

### Long-Term: StateManager Deprecation?

StateManager is a **hybrid**:
- Some state delegated to ApplicationState (current_frame, selection)
- Some state local (zoom_level, image_files)

**Question**: Should we fully migrate to ApplicationState and deprecate StateManager?

**Answer**: Defer to Phase 9 (2026):
- ApplicationState handles **data** (curves, frames, selection)
- StateManager handles **UI preferences** (zoom, smoothing, window state)
- Keep separation for now - it's architecturally sound

---

## Appendix: Signal Reference

### Existing Signals (10)
```python
file_changed: Signal = Signal(str)
modified_changed: Signal = Signal(bool)
view_state_changed: Signal = Signal()
selection_changed: Signal = Signal(set)
frame_changed: Signal = Signal(int)
total_frames_changed: Signal = Signal(int)
playback_state_changed: Signal = Signal(object)
active_timeline_point_changed: Signal = Signal(object)
```

### Proposed New Signals (6)
```python
# Phase 1 - Critical
track_data_changed: Signal = Signal(list)             # Emits list[tuple[float, float]]
image_files_changed: Signal = Signal(list)            # Emits list[str]
undo_state_changed: Signal = Signal(bool)             # Emits can_undo
redo_state_changed: Signal = Signal(bool)             # Emits can_redo

# Phase 2 - Important
image_directory_changed: Signal = Signal(str)         # Emits directory path or ""
current_tool_changed: Signal = Signal(str)            # Emits tool name
```

### Total After Refactor: 16 signals

---

## Document History

- **2025-10-07**: Initial plan after `total_frames_changed` bug fix
- **Author**: Analysis of StateManager signal architecture
- **Status**: DRAFT - Awaiting approval for Phase 1 execution

---

*End of Refactor Plan*
