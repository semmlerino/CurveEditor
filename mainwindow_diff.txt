--- ui/main_window.py	2025-09-14 00:38:20.908452300 +0100
+++ ui/modernized_main_window.py	2025-09-13 17:39:53.913658000 +0100
@@ -1,576 +1,766 @@
 #!/usr/bin/env python
-# pyright: reportUnknownMemberType=false, reportUnknownVariableType=false, reportMissingTypeStubs=false, reportUnknownArgumentType=false, reportUnknownParameterType=false, reportImportCycles=false
-# -*- coding: utf-8 -*-
-
 """
-Main Window for 3DE4 Curve Editor.
-
-This module contains the MainWindow class which serves as the main entry point
-for the Curve Editor application. It has been refactored to delegate most
-functionality to specialized classes for better maintainability.
-
-Key architecture components:
-1. ApplicationState - Manages all application state variables
-2. UIInitializer - Handles UI component initialization
-3. Direct service access through ServiceRegistryV2
-5. Service classes - Handle specific functionality
+Modernized Main Window for CurveEditor
+Extends the base MainWindow with comprehensive modern UI/UX enhancements
 """

-# Standard library imports
 import logging
-import sys
-from typing import TYPE_CHECKING, Any, Optional
-
-if TYPE_CHECKING:
-    from controllers.data_controller import DataController
-    from io_utils.file_load_worker import FileLoadSignals, FileLoadWorker
-    from ui.timeline_tabs import TimelineTabWidget

-    from .curve_view_widget import CurveViewWidget
-
-# Import PySide6 modules
-from PySide6.QtCore import QEvent, QObject, Qt, QTimer, Signal, Slot
+from PySide6.QtCore import (
+    QEasingCurve,
+    QEvent,
+    QParallelAnimationGroup,
+    QPropertyAnimation,
+    Qt,
+    QTimer,
+    Signal,
+    Slot,
+)
 from PySide6.QtGui import (
+    QAction,
+    QColor,
     QKeyEvent,
+    QKeySequence,
+    QResizeEvent,
 )
 from PySide6.QtWidgets import (
-    QApplication,
-    QCheckBox,
-    QDockWidget,
-    QDoubleSpinBox,
+    QGraphicsOpacityEffect,
     QLabel,
-    QMainWindow,
     QPushButton,
-    QSlider,
-    QSpinBox,
+    QToolBar,
     QWidget,
 )

-from core.curve_data import CurveDataWithMetadata
+from .animation_utils import AnimationFactory
+from .main_window import MainWindow
+from .modern_theme import ModernTheme
+from .modern_widgets import (
+    ModernLoadingSpinner,
+    ModernProgressBar,
+    ModernToast,
+)
+from .ui_constants import COLORS_DARK, COLORS_LIGHT

-from .curve_view_widget import CurveViewWidget
-from .state_manager import StateManager
+logger = logging.getLogger("modernized_main_window")

-# Import refactored components

-# Configure logger for this module
-logger = logging.getLogger("main_window")
-
-
-class MainWindow(QMainWindow):  # Implements MainWindowProtocol (structural typing)
-    """Main application window for the Curve Editor."""
-
-    play_toggled: Signal = Signal(bool)
-    frame_rate_changed: Signal = Signal(int)
-
-    # These are initialized by MainWindowInitializer but need type annotations
-    state_manager: StateManager
-    tracked_data: dict[str, list[tuple[int, float, float]]]
-    active_points: list[str]
-
-    frame_spinbox: QSpinBox | None = None
-    total_frames_label: QLabel | None = None
-    frame_slider: QSlider | None = None
-    timeline_tabs: "TimelineTabWidget | None" = None
-    btn_play_pause: QPushButton | None = None  # Used for playback control (not visible but functional)
-    fps_spinbox: QSpinBox | None = None
-    playback_timer: QTimer | None = None
-    curve_widget: "CurveViewWidget | None" = None
-
-    file_load_worker: Optional["FileLoadWorker"] = None
-    file_load_signals: Optional["FileLoadSignals"] = None
-    data_controller: Optional["DataController"] = None
-
-    tracking_panel_dock: QDockWidget | None = None
-    selected_point_label: QLabel | None = None
-    point_x_spinbox: QDoubleSpinBox | None = None
-    point_y_spinbox: QDoubleSpinBox | None = None
-    show_background_cb: QCheckBox | None = None
-    show_grid_cb: QCheckBox | None = None
-    show_info_cb: QCheckBox | None = None
-    show_tooltips_cb: QCheckBox | None = None
-    point_size_label: QLabel | None = None
-    line_width_label: QLabel | None = None
-    point_size_slider: QSlider | None = None
-    line_width_slider: QSlider | None = None
+class ModernizedMainWindow(MainWindow):
+    """Enhanced main window with comprehensive modern UI/UX features."""

-    def __init__(self, parent: QWidget | None = None, initial_data_file: str | None = None):
-        """Initialize the MainWindow with enhanced UI functionality."""
-        super().__init__(parent)
+    # Additional signals for modern features
+    theme_changed: Signal = Signal(str)
+    animation_toggled: Signal = Signal(bool)
+    keyboard_hints_toggled: Signal = Signal(bool)

-        # Use streamlined initialization via MainWindowInitializer
-        from .main_window_initializer import MainWindowInitializer
+    # Modern UI components - initialized in setup methods
+    progress_bar_modern: ModernProgressBar | None = None
+    loading_spinner: ModernLoadingSpinner | None = None

-        initializer = MainWindowInitializer(self)
-        initializer.perform_full_initialization(initial_data_file)
-        logger.info("MainWindow initialized successfully")
+    def __init__(self, parent: QWidget | None = None, initial_data_file: str | None = None):
+        """Initialize the modernized main window."""
+        # Initialize theme manager before parent init
+        self.theme_manager: ModernTheme = ModernTheme()
+        self.animations_enabled: bool = True
+        self.current_theme: str = "dark"  # Default to dark theme
+        self.keyboard_hints_visible: bool = False
+
+        # Initialize animation containers
+        self._pulse_animations: list[QPropertyAnimation] = []
+        self._button_animations: dict[str, object] = {}
+
+        # Initialize parent (MainWindow)
+        super().__init__(parent, initial_data_file)
+
+        # Apply modern enhancements after parent initialization
+        self._apply_modern_theme()
+        self._enhance_ui_components()
+        self._setup_animations()
+        self._add_keyboard_hints()
+        self._setup_loading_indicators()
+        self._add_theme_switcher()
+        self._enhance_timeline()
+        self._enhance_toolbar()
+        self._add_welcome_animation()
+
+        # Setup keyboard shortcuts for modern features
+        self._setup_modern_shortcuts()
+
+        logger.info("ModernizedMainWindow initialized with enhanced UI/UX")
+
+    def _apply_modern_theme(self):
+        """Apply the modern theme to the application."""
+        # Set dark theme as default
+        self.theme_manager.current_theme = self.current_theme
+
+        # Apply comprehensive stylesheet
+        stylesheet = self.theme_manager.get_stylesheet()
+        self.setStyleSheet(stylesheet)
+
+        # Apply window-specific dark theme enhancements
+        if self.current_theme == "dark":
+            self.setStyleSheet(
+                self.styleSheet()
+                + """
+                QMainWindow {
+                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
+                        stop:0 #2b3035, stop:1 #212529);
+                }
+
+                QToolBar {
+                    background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
+                        stop:0 #343a40, stop:1 #2b3035);
+                    border-bottom: 1px solid #495057;
+                }
+
+                QStatusBar {
+                    background: qlineargradient(x1:0, y1:1, x2:0, y2:0,
+                        stop:0 #212529, stop:1 #2b3035);
+                    border-top: 1px solid #495057;
+                    color: #adb5bd;
+                }
+
+                /* Enhanced timeline tabs */
+                QToolButton {
+                    /* Transition effect handled by animations */
+                }
+
+                QToolButton:hover {
+                    margin-top: -2px;
+                }
+            """
+            )
+
+    def _enhance_ui_components(self):
+        """Enhance existing UI components with modern features."""
+        # Apply card shadows to GroupBoxes
+        for group_box in self.findChildren(QWidget):
+            if group_box.__class__.__name__ == "QGroupBox":
+                self._apply_card_effect(group_box)
+
+        # Enhance buttons with hover effects
+        for button in self.findChildren(QPushButton):
+            self._enhance_button(button)

-    @Slot(str)
-    def _on_file_changed(self, file_path: str) -> None:
-        """Handle file path changes."""
-        if self.data_controller:
-            self.data_controller.handle_file_changed(file_path)
+        # Enhance the curve widget
+        # curve_widget is Optional, inherited from MainWindow
+        if self.curve_widget is not None:
+            self._enhance_curve_widget()

-    @Slot(bool)
-    def _on_modified_changed(self, modified: bool) -> None:
-        """Handle modification status changes."""
-        self.state_change_controller.handle_modified_changed(modified)
+    def _apply_card_effect(self, widget: QWidget):
+        """Apply modern card effect with shadow to widget."""
+        # Use AnimationFactory for consistent shadow creation
+        alpha = 40 if self.current_theme == "light" else 60
+        shadow = AnimationFactory.create_shadow_effect(
+            blur_radius=15,
+            x_offset=0,
+            y_offset=2,
+        )
+        shadow.setColor(QColor(0, 0, 0, alpha))
+        widget.setGraphicsEffect(shadow)
+
+        # Add hover animation capability
+        widget.setProperty("card_shadow", shadow)
+
+    def _enhance_button(self, button: QPushButton):
+        """Enhance button with modern hover effects."""
+        button.setCursor(Qt.CursorShape.PointingHandCursor)
+        button.setProperty("enhanced", True)
+
+        # Install event filter for hover animations
+        button.installEventFilter(self)
+
+    def _enhance_curve_widget(self):
+        """Enhance the curve widget with modern styling."""
+        colors = COLORS_DARK if self.current_theme == "dark" else COLORS_LIGHT

-    @Slot(str)
-    def _on_shortcut_activated(self, shortcut_name: str) -> None:
-        """Handle keyboard shortcut activation."""
-        logger.debug(f"Shortcut activated: {shortcut_name}")
-        # Map shortcut names to actions
-        shortcut_map = {
-            "new_file": self.action_new,
-            "open_file": self.action_open,
-            "save_file": self.action_save,
-            "save_as": self.action_save_as,
-            "undo": self.action_undo,
-            "redo": self.action_redo,
-            "zoom_in": self.action_zoom_in,
-            "zoom_out": self.action_zoom_out,
-            "reset_view": self.action_reset_view,
-            "next_frame": lambda: self._on_next_frame(),
-            "prev_frame": lambda: self._on_prev_frame(),
-            "first_frame": lambda: self._on_first_frame(),
-            "last_frame": lambda: self._on_last_frame(),
-        }
-
-        if shortcut_name in shortcut_map:
-            action_or_func = shortcut_map[shortcut_name]
-            if action_or_func is None:
-                logger.warning(f"Action for shortcut '{shortcut_name}' is not initialized")
-            elif callable(action_or_func):
-                action_or_func()
-            else:
-                action_or_func.trigger()
+        if self.curve_widget is not None:
+            self.curve_widget.setStyleSheet(f"""
+            CurveViewWidget {{
+                border: 2px solid {colors['border_default']};
+                border-radius: 8px;
+                background: {colors['bg_elevated']};
+            }}
+            CurveViewWidget:focus {{
+                border: 2px solid {colors['accent_primary']};
+                /* Shadow effect handled by QGraphicsDropShadowEffect */
+            }}
+        """)
+
+    def _enhance_toolbar(self):
+        """Enhance the existing toolbar with modern styling."""
+        # Find existing toolbar
+        toolbar = self.findChild(QToolBar, "mainToolBar")
+        if not toolbar:
+            return

-        self.view_controller.update_status(f"Shortcut: {shortcut_name}")
+        # Apply modern styling to toolbar actions
+        colors = COLORS_DARK if self.current_theme == "dark" else COLORS_LIGHT
+        toolbar.setStyleSheet(f"""
+            QToolBar {{
+                spacing: 4px;
+                padding: 4px;
+            }}
+            QToolButton {{
+                border-radius: 4px;
+                padding: 6px;
+                margin: 2px;
+            }}
+            QToolButton:hover {{
+                background: {colors['bg_hover']};
+            }}
+        """)
+
+    def _setup_animations(self):
+        """Setup animation controllers for smooth transitions."""
+        self.animation_group: QParallelAnimationGroup = QParallelAnimationGroup()
+        self.fade_animations: dict[QWidget, QPropertyAnimation] = {}
+
+        # Setup opacity effects for smooth transitions
+        # Only animate the curve container (side panels removed)
+        for widget_name in ["curve_container"]:
+            widget = getattr(self, widget_name, None)
+            if widget and isinstance(widget, QWidget):
+                # Use AnimationFactory for consistent animation creation
+                opacity_effect, fade_anim = AnimationFactory.create_opacity_animation(
+                    widget,
+                    duration="normal",
+                    start_value=1.0,
+                    end_value=1.0,
+                    easing=QEasingCurve.Type.InOutCubic,
+                )
+                self.fade_animations[widget] = fade_anim
+
+    def _add_keyboard_hints(self):
+        """Add visual keyboard navigation hints."""
+        self.keyboard_hints: list[QLabel] = []
+
+        # Create keyboard hint overlays for important controls
+        hint_configs = [
+            (self.frame_spinbox, "â†‘â†“", "Adjust frame"),
+            (self.btn_play_pause, "Space", "Play/Pause"),
+            (self.point_x_spinbox, "Tab", "Navigate"),
+        ]
+
+        for widget, key, description in hint_configs:
+            if widget:
+                hint = self._create_keyboard_hint(widget, key, description)
+                self.keyboard_hints.append(hint)
+
+    def _create_keyboard_hint(self, target_widget: QWidget, key: str, description: str) -> QLabel:
+        """Create a keyboard hint overlay for a widget."""
+        parent_widget = target_widget.parent()
+        if isinstance(parent_widget, QWidget):
+            hint_parent = parent_widget
+        else:
+            hint_parent = self
+        hint = QLabel(f"{key}", hint_parent)
+        hint.setStyleSheet("""
+            QLabel {
+                background: rgba(0, 123, 255, 0.9);
+                color: white;
+                border-radius: 4px;
+                padding: 2px 6px;
+                font-size: 11px;
+                font-weight: bold;
+            }
+        """)
+        hint.setToolTip(description)
+        # Store reference to target widget for positioning
+        hint.setProperty("target_widget", target_widget)
+        hint.setProperty("description", description)
+        hint.hide()
+        hint.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents)
+        return hint
+
+    def _setup_loading_indicators(self):
+        """Setup loading indicators for async operations."""
+        # Create loading spinner
+        self.loading_spinner = ModernLoadingSpinner(self)
+        self.loading_spinner.move(self.width() // 2 - 20, self.height() // 2 - 20)
+        self.loading_spinner.hide()
+
+        # Create progress bar for file operations
+        self.progress_bar_modern = ModernProgressBar(self)
+        self.progress_bar_modern.setFixedWidth(300)
+        self.progress_bar_modern.move(self.width() // 2 - 150, self.height() - 100)
+        self.progress_bar_modern.hide()
+
+    def _add_theme_switcher(self):
+        """Add theme switching capability to toolbar."""
+        toolbar = self.findChild(QToolBar, "mainToolBar")
+        if toolbar:
+            # Add separator before theme toggle
+            toolbar.addSeparator()
+
+            # Create theme switcher action
+            theme_action = QAction("ðŸŒ™" if self.current_theme == "light" else "â˜€ï¸", self)
+            theme_action.setToolTip("Switch theme (Ctrl+T)")
+            theme_action.setShortcut(QKeySequence("Ctrl+T"))
+            theme_action.triggered.connect(self._toggle_theme)
+            toolbar.addAction(theme_action)
+            self.theme_action: QAction = theme_action
+
+            # Add performance mode toggle
+            perf_action = QAction("ðŸš€ Performance Mode", self)
+            perf_action.setCheckable(True)
+            perf_action.setToolTip("Toggle performance mode (Ctrl+P)")
+            perf_action.setShortcut(QKeySequence("Ctrl+P"))
+            perf_action.triggered.connect(self._toggle_performance_mode)
+            toolbar.addAction(perf_action)
+            self.perf_action: QAction = perf_action
+
+    def _enhance_timeline(self):
+        """Enhance the timeline with modern styling and animations."""
+        # TODO: Implement timeline enhancement properly for TimelineTabWidget
+        # The timeline_tabs is a widget container, not an enumerable list of tabs
+        pass
+
+    def _add_pulse_animation(self, widget: QWidget):
+        """Add subtle pulse animation to widget."""
+        if not widget or not isinstance(widget, QWidget):
+            return

-    # Timeline Control Handlers ====================
-
-    @Slot(bool)
-    def _on_play_pause(self, checked: bool) -> None:
-        """Handle play/pause toggle."""
-        self.interaction_controller.handle_play_pause(checked)
+        opacity_effect = QGraphicsOpacityEffect()
+        opacity_effect.setOpacity(1.0)  # Set initial opacity
+        widget.setGraphicsEffect(opacity_effect)
+
+        pulse_anim = QPropertyAnimation(opacity_effect, b"opacity")
+        pulse_anim.setDuration(1000)
+        pulse_anim.setStartValue(1.0)
+        pulse_anim.setKeyValueAt(0.5, 0.7)
+        pulse_anim.setEndValue(1.0)
+        pulse_anim.setLoopCount(-1)  # Infinite loop
+        pulse_anim.setEasingCurve(QEasingCurve.Type.InOutSine)
+
+        # Store animation reference to prevent garbage collection
+        self._pulse_animations.append(pulse_anim)
+
+        pulse_anim.start()
+        widget.setProperty("pulse_animation", pulse_anim)
+
+    def _add_welcome_animation(self):
+        """Show welcome animation on startup."""
+
+        def show_welcome():
+            try:
+                # Check if window still exists
+                if not self or not self.isVisible():
+                    return
+
+                # Create welcome toast
+                toast = ModernToast("Welcome to CurveEditor! Press F1 for keyboard shortcuts.", "info", 4000, self)
+                toast.move(self.width() - toast.width() - 20, 60)
+                toast.show_toast()
+
+                # Animate main panel with fade-in (only curve container now)
+                for widget_name in ["curve_container"]:
+                    widget = getattr(self, widget_name, None)
+                    if widget and widget in self.fade_animations:
+                        try:
+                            fade_anim = self.fade_animations[widget]
+                            fade_anim.setStartValue(0.0)
+                            fade_anim.setEndValue(1.0)
+                            fade_anim.start()
+                        except RuntimeError:
+                            # Animation object may have been deleted during teardown
+                            pass
+            except RuntimeError:
+                # Window was deleted
+                pass
+
+        # Delay welcome animation slightly
+        QTimer.singleShot(500, show_welcome)
+
+    def _setup_modern_shortcuts(self):
+        """Setup keyboard shortcuts for modern features."""
+        # F1 - Toggle keyboard hints
+        # F2 - Toggle animations
+        # Ctrl+T - Toggle theme
+        pass  # Shortcuts are connected via actions

     @Slot()
-    def _on_playback_timer(self) -> None:
-        """Handle oscillating playback timer tick."""
-        self.interaction_controller.handle_playback_timer()
-
-    @Slot(int)
-    def _on_fps_changed(self, value: int) -> None:
-        """Handle FPS change."""
-        self.interaction_controller.handle_fps_changed(value)
-
-    # ================ Oscillating Timeline Playback Methods ================
-
-
-
-
-    def _update_playback_bounds(self) -> None:
-        """Update playback frame bounds based on current data."""
-        # Delegate to controller
-        self.interaction_controller._update_bounds()
-
+    def _toggle_theme(self):
+        """Toggle between light and dark themes."""
+        # Switch theme
+        self.current_theme = "dark" if self.current_theme == "light" else "light"
+        self.theme_manager.switch_theme(self.current_theme)
+
+        # Apply new theme
+        self._apply_modern_theme()
+        self._enhance_ui_components()
+        self._enhance_timeline()
+
+        # Update theme button icon
+        if getattr(self, "theme_action", None) is not None:
+            self.theme_action.setText("ðŸŒ™" if self.current_theme == "light" else "â˜€ï¸")
+
+        # Show theme change notification
+        self._show_notification(f"Switched to {self.current_theme.title()} Theme", "success")
+
+        # Emit theme changed signal
+        self.theme_changed.emit(self.current_theme)
+
+        logger.info(f"Theme switched to: {self.current_theme}")
+
+    def _show_notification(self, message: str, variant: str = "info", duration: int = 3000):
+        """Show a modern toast notification."""
+        toast = ModernToast(message, variant, duration, self)
+        toast.move(self.width() - toast.width() - 20, 60)
+        toast.show_toast()

-    @property
-    def current_frame(self) -> int:
-        """Get the current frame number.
-
-        Property accessor for better type safety and compatibility.
-        Provides a clean interface for accessing the current frame.
-        """
-        return self.view_controller.get_current_frame()
-
-    @current_frame.setter
-    def current_frame(self, value: int) -> None:
-        """Set the current frame number.
-
-        Property setter for better type safety and compatibility.
-        Provides a clean interface for setting the current frame.
-        """
-        self.view_controller.navigate_to_frame(value, update_state_manager=True)
-
-    @property
-    def is_modified(self) -> bool:
-        """Get modified state (proxy to state_manager.is_modified)."""
-        return self.state_manager.is_modified if self.state_manager else False
-
-    @property
-    def total_frames(self) -> int:
-        """Get total number of frames."""
-        return self.state_manager.total_frames if self.state_manager else 0
-
-    @total_frames.setter
-    def total_frames(self, value: int) -> None:
-        """Set total number of frames."""
-        if self.state_manager:
-            self.state_manager.total_frames = value
-
-    @property
-    def zoom_level(self) -> float:
-        """Get current zoom level."""
-        return self.state_manager.zoom_level if self.state_manager else 1.0
-
-    @zoom_level.setter
-    def zoom_level(self, value: float) -> None:
-        """Set zoom level."""
-        if self.state_manager:
-            self.state_manager.zoom_level = value
-
-    @Slot(int)
-    def _on_timeline_tab_clicked(self, frame: int) -> None:
-        """Handle timeline tab click to navigate to frame."""
-        self.timeline_controller.handle_timeline_tab_clicked(frame)
-
-    @Slot(int)
-    def _on_timeline_tab_hovered(self, frame: int) -> None:  # pyright: ignore[reportUnusedParameter]
-        """Handle timeline tab hover for preview (optional feature)."""
-        self.timeline_controller.handle_timeline_tab_hovered(frame)
-
-    # Action Handlers ====================
-
-    def _load_session_or_fallback(self) -> None:
-        """Load session data if available, otherwise fallback to burger data."""
-        self.session_manager.load_session_or_fallback(self)
-
-    def _restore_session_state(self, session_data: dict[str, Any]) -> None:
-        """Restore application state from session data."""
-        self.session_manager.restore_session_state(self, session_data)
-
-    def _load_burger_tracking_data(self) -> None:
-        """Auto-load burger footage and tracking data if available using background thread."""
-        self.data_controller.load_burger_tracking_data()
-
-    def _cleanup_file_load_thread(self) -> None:
-        """Clean up file loading thread - stops Python thread if running."""
-        self.data_controller.cleanup_file_load_thread()
-
-    @Slot(object)
-    def _on_tracking_data_loaded(
-        self, data: list[tuple[int, float, float] | tuple[int, float, float, str]] | CurveDataWithMetadata
-    ) -> None:
-        """Handle tracking data loaded in background thread."""
-        if self.data_controller:
-            self.data_controller.handle_tracking_data_loaded(data, "default")
-
-    @Slot(str, list)
-    def _on_image_sequence_loaded(self, image_dir: str, image_files: list[str]) -> None:
-        """Handle image sequence loaded in background thread."""
-        if self.data_controller:
-            self.data_controller.handle_image_sequence_loaded(image_dir, image_files)
-
-    def update_status(self, message: str) -> None:
-        """Update the status bar with a message.
+    @Slot(bool)
+    def _toggle_performance_mode(self, enabled: bool):
+        """Toggle performance mode for better responsiveness.

         Args:
-            message: Status message to display
+            enabled: True to enable performance mode
         """
-        self.statusBar().showMessage(message)
-
-    @Slot(int, str)
-    def _on_file_load_progress(self, progress: int, message: str) -> None:
-        """Handle file loading progress updates."""
-        if self.data_controller:
-            self.data_controller.handle_file_load_progress(progress, message)
+        if enabled:
+            # Disable expensive visual effects
+            self.animations_enabled = False
+
+            # Disable graphics effects on widgets
+            for widget in self.findChildren(QWidget):
+                if widget.graphicsEffect():
+                    widget.graphicsEffect().setEnabled(False)
+
+            # Stop all animations
+            for widget, anim in self.fade_animations.items():
+                anim.stop()
+
+            # Use faster rendering in curve widget if available
+            # curve_widget is Optional, inherited from MainWindow
+            if self.curve_widget is not None:
+                renderer = getattr(self.curve_widget, "renderer", None)
+                if renderer is not None and getattr(renderer, "set_render_quality", None) is not None:
+                    from rendering.optimized_curve_renderer import RenderQuality
+
+                    renderer.set_render_quality(RenderQuality.DRAFT)
+
+            self._show_notification("Performance mode enabled - animations disabled", "success", 2000)
+        else:
+            # Re-enable visual effects
+            self.animations_enabled = True
+
+            # Re-enable graphics effects
+            for widget in self.findChildren(QWidget):
+                if widget.graphicsEffect():
+                    widget.graphicsEffect().setEnabled(True)
+
+            # Restore normal rendering
+            # curve_widget is Optional, inherited from MainWindow
+            if self.curve_widget is not None:
+                renderer = getattr(self.curve_widget, "renderer", None)
+                if renderer is not None and getattr(renderer, "set_render_quality", None) is not None:
+                    from rendering.optimized_curve_renderer import RenderQuality
+
+                    renderer.set_render_quality(RenderQuality.NORMAL)
+
+            self._show_notification("Performance mode disabled - animations enabled", "info", 2000)
+
+    def toggle_keyboard_hints(self):
+        """Toggle visibility of keyboard hints."""
+        self.keyboard_hints_visible = not self.keyboard_hints_visible
+
+        for hint in self.keyboard_hints:
+            if self.keyboard_hints_visible:
+                hint.show()
+                # Position hint near its target widget
+                self._position_keyboard_hint(hint)
+            else:
+                hint.hide()

-    @Slot(str)
-    def _on_file_load_error(self, error_message: str) -> None:
-        """Handle file loading errors."""
-        if self.data_controller:
-            self.data_controller.handle_file_load_error(error_message)
+        self._show_notification(f"Keyboard hints {'shown' if self.keyboard_hints_visible else 'hidden'}", "info", 2000)

-    @Slot()
-    def _on_file_load_finished(self) -> None:
-        """Handle file loading completion - worker ready for next load."""
-        if self.data_controller:
-            self.data_controller.handle_file_load_finished()
-
-    def update_background_image_for_frame(self, frame: int) -> None:
-        """Update the background image based on the current frame."""
-        # Delegate to frame navigation controller
-        self.view_controller._update_background_image_for_frame(frame)
+        self.keyboard_hints_toggled.emit(self.keyboard_hints_visible)

-    @Slot()
-    def _on_action_undo(self) -> None:
-        """Handle undo action."""
-        self.state_change_controller.handle_action_undo()
+    def _position_keyboard_hint(self, hint: QLabel) -> None:
+        """Position keyboard hint near its target widget."""
+        target_widget = hint.property("target_widget")
+        if target_widget and target_widget.isVisible():
+            # Get target widget's geometry
+            target_rect = target_widget.rect()
+
+            # Map to main window coordinates
+            if target_widget.parent():
+                pos = target_widget.mapTo(self, target_rect.topRight())
+            else:
+                pos = target_widget.pos() + target_rect.topRight()

-    @Slot()
-    def _on_action_redo(self) -> None:
-        """Handle redo action."""
-        self.state_change_controller.handle_action_redo()
-
-    # State Change Handlers ====================
-
-    @Slot(list)
-    def _on_selection_changed(self, indices: list[int]) -> None:
-        """Handle selection change from state manager."""
-        self.state_change_controller.handle_selection_changed(indices)
+            # Position hint at top-right corner, slightly offset
+            hint_x = pos.x() - hint.width() - 5
+            hint_y = pos.y() - hint.height() + 5
+
+            # Ensure hint stays within window bounds
+            hint_x = max(5, min(hint_x, self.width() - hint.width() - 5))
+            hint_y = max(5, hint_y)

-    @Slot()
-    def _on_view_state_changed(self) -> None:
-        """Handle view state change from state manager."""
-        self.state_change_controller.handle_view_state_changed()
-
-    # UI Update Methods ====================
-
-    def update_ui_state(self) -> None:
-        """Update UI elements based on current state."""
-        # Delegate all UI state updates to ViewUpdateManager
-        self.view_controller.update_ui_state()
-
-
-    def eventFilter(self, watched: QObject, event: QEvent) -> bool:
-        """Event filter to handle key event redirection."""
-        # Delegate to EventFilterController
-        if self.event_filter_controller.filter_event(watched, event):
-            return True
-        return super().eventFilter(watched, event)  # Proper delegation to parent
-
-    def update_cursor_position(self, x: float, y: float) -> None:
-        """Update cursor position in status bar."""
-        self.view_controller.update_cursor_position(x, y)
-
-    # Curve Widget Signal Handlers ====================
-
-    @Slot(int)
-    def _on_point_selected(self, index: int) -> None:
-        """Handle point selection from curve widget."""
-        self.interaction_controller.on_point_selected(index)
-
-    @Slot(int, float, float)
-    def _on_point_moved(self, index: int, x: float, y: float) -> None:
-        """Handle point movement from curve widget."""
-        self.interaction_controller.on_point_moved(index, x, y)
-
-    @Slot(list)
-    def _on_curve_selection_changed(self, indices: list[int]) -> None:
-        """Handle selection change from curve widget."""
-        self.state_change_controller.handle_curve_selection_changed(indices)
+            hint.move(hint_x, hint_y)
+            hint.raise_()  # Ensure hint is on top

-    @Slot()
-    def _on_curve_view_changed(self) -> None:
-        """Handle view changes from curve widget."""
-        self.state_change_controller.handle_curve_view_changed()
-
-    @Slot(float)
-    def _on_curve_zoom_changed(self, zoom: float) -> None:
-        """Handle zoom changes from curve widget."""
-        self.state_change_controller.handle_curve_zoom_changed(zoom)
-
-    # Tracking Points Panel Handlers ====================
-
-    def _on_tracking_points_selected(self, point_names: list[str]) -> None:
-        """Handle selection of tracking points from panel."""
-        self.interaction_controller.on_tracking_points_selected(point_names)
-
-    def _on_point_visibility_changed(self, point_name: str, visible: bool) -> None:
-        """Handle visibility change for a tracking point."""
-        self.interaction_controller.on_point_visibility_changed(point_name, visible)
-
-    def _on_point_color_changed(self, point_name: str, color: str) -> None:
-        """Handle color change for a tracking point."""
-        self.interaction_controller.on_point_color_changed(point_name, color)
-
-    def _on_point_deleted(self, point_name: str) -> None:
-        """Handle deletion of a tracking point."""
-        self.interaction_controller.on_point_deleted(point_name)
-
-    def _on_point_renamed(self, old_name: str, new_name: str) -> None:
-        """Handle renaming of a tracking point."""
-        self.interaction_controller.on_point_renamed(old_name, new_name)
-
-    def update_tracking_panel(self) -> None:
-        """Update tracking panel with current tracking data."""
-        self.interaction_controller.update_tracking_panel()
-
-    def update_curve_display(self) -> None:
-        """Update curve display with selected tracking points."""
-        self.interaction_controller.update_curve_display()
-
-    # View Options Handlers ====================
-
-    def update_curve_view_options(self) -> None:
-        """Update curve widget view options based on checkboxes."""
-        self.view_controller.update_curve_view_options()
-
-    @Slot(int)
-    def _update_curve_point_size(self, value: int) -> None:
-        """Update curve widget point size."""
-        self.view_controller.update_curve_point_size(value)
-
-    @Slot(int)
-    def _update_curve_line_width(self, value: int) -> None:
-        """Update curve widget line width."""
-        self.view_controller.update_curve_line_width(value)
-
-    def toggle_tooltips(self) -> None:
-        """Toggle tooltips on/off globally."""
-        self.view_controller.toggle_tooltips()
-
-    # Frame Navigation Handlers ====================
-
-    @Slot(int)
-    def _on_state_frame_changed(self, frame: int) -> None:
-        """Handle frame change from state manager."""
-        self.state_change_controller.handle_state_frame_changed(frame)
-
-    def _on_frame_changed(self, frame: int) -> None:
-        """Handle frame change (delegation for backward compatibility)."""
-        self.view_controller.navigate_to_frame(frame, update_state_manager=True)
-
-    def navigate_to_frame(self, frame: int, update_state_manager: bool = True) -> None:
-        """Navigate to specified frame (delegation for backward compatibility)."""
-        self.view_controller.navigate_to_frame(frame, update_state_manager)
-
-    def _get_current_frame(self) -> int:
-        """Get current frame (protected method for PlaybackController)."""
-        return self.state_manager.current_frame
-
-    def _set_current_frame(self, frame: int) -> None:
-        """Set current frame (protected method for PlaybackController)."""
-        self.view_controller.navigate_to_frame(frame, update_state_manager=True)
-
-    # Utility Methods ====================
-
-    def update_timeline_tabs(
-        self, curve_data: list[tuple[int, float, float] | tuple[int, float, float, str]] | None = None
-    ) -> None:
-        """Update timeline tabs with current curve data and frame range."""
-        self.timeline_controller.update_timeline_tabs(curve_data)
-
-    def _get_current_curve_data(self) -> list[tuple[int, float, float] | tuple[int, float, float, str]]:
-        """Get current curve data from curve widget or state manager."""
-        return self.data_controller.get_current_curve_data()  # pyright: ignore[reportReturnType]
-
-    def add_to_history(self) -> None:
-        """Add current state to history (called by curve widget)."""
-        self.services.add_to_history()
+    def keyPressEvent(self, event: QKeyEvent) -> None:
+        """Enhanced key press handling with visual feedback."""
+        # Toggle keyboard hints with F1
+        if event.key() == Qt.Key.Key_F1:
+            self.toggle_keyboard_hints()
+            return

-    def restore_state(self, state: dict[str, object]) -> None:
-        """Restore state from history.
+        # Toggle animations with F2
+        if event.key() == Qt.Key.Key_F2:
+            self.animations_enabled = not self.animations_enabled
+            self._show_notification(f"Animations {'enabled' if self.animations_enabled else 'disabled'}", "info", 2000)
+            self.animation_toggled.emit(self.animations_enabled)
+            return

-        Args:
-            state: History state dictionary containing curve data and other state
-        """
-        if self.services:
-            self.services.restore_state(state)
+        # Call parent key press handler
+        super().keyPressEvent(event)

-        # Update history-related UI state through ViewUpdateManager
-        self.view_controller.update_undo_redo_state(self.state_manager.can_undo, self.state_manager.can_redo)
+    def resizeEvent(self, event: QResizeEvent) -> None:
+        """Handle window resize events."""
+        super().resizeEvent(event)
+
+        # Reposition keyboard hints if they're visible
+        if self.keyboard_hints_visible:
+            for hint in self.keyboard_hints:
+                self._position_keyboard_hint(hint)
+
+        # Reposition loading indicators
+        if self.loading_spinner is not None:
+            self.loading_spinner.move(self.width() // 2 - 20, self.height() // 2 - 20)

-    @Slot(float)
-    def _on_point_x_changed(self, value: float) -> None:
-        """Handle X coordinate change in properties panel."""
-        self.interaction_controller.on_point_x_changed(value)
-
-    @Slot(float)
-    def _on_point_y_changed(self, value: float) -> None:
-        """Handle Y coordinate change in properties panel."""
-        self.interaction_controller.on_point_y_changed(value)
-
-    # Public Methods for External Use ====================
-
-    def set_curve_view(self, curve_view: CurveViewWidget | None) -> None:
-        """Set the curve view widget (legacy method - now uses CurveViewWidget)."""
-        self.curve_view = curve_view
-        logger.info("Legacy curve view reference set")
-
-    def get_view_options(self) -> dict[str, object]:
-        """Get current view options."""
-        return {
-            "show_background": self.show_background_cb.isChecked() if self.show_background_cb else False,
-            "show_grid": self.show_grid_cb.isChecked() if self.show_grid_cb else True,
-            "show_info": self.show_info_cb.isChecked() if self.show_info_cb else True,
-            "point_size": self.point_size_slider.value() if self.point_size_slider else 5,
-            "line_width": self.line_width_slider.value() if self.line_width_slider else 2,
-        }
+        if self.progress_bar_modern is not None:
+            self.progress_bar_modern.move(self.width() // 2 - 150, self.height() - 100)

-    def set_centering_enabled(self, enabled: bool) -> None:
-        """Enable or disable auto-centering on frame change.
+    def closeEvent(self, event: QEvent) -> None:
+        """Clean up animations and resources."""
+        # Stop and clean up fade animations
+        for widget, anim in self.fade_animations.items():
+            if anim and anim.state() == QPropertyAnimation.State.Running:
+                anim.stop()
+            anim.deleteLater()
+
+        # Stop and clean up pulse animations
+        if getattr(self, "_pulse_animations", None) is not None:
+            for anim in self._pulse_animations:
+                if anim and anim.state() == QPropertyAnimation.State.Running:
+                    anim.stop()
+                anim.deleteLater()
+
+        # Stop and clean up button animations
+        if getattr(self, "_button_animations", None) is not None:
+            for key, obj in self._button_animations.items():
+                if isinstance(obj, QPropertyAnimation):
+                    if obj.state() == QPropertyAnimation.State.Running:
+                        obj.stop()
+                    obj.deleteLater()
+
+        # Stop pulse animations on timeline tabs
+        # ui_components is initialized in MainWindow.__init__, timeline may not exist
+        ui_components = getattr(self, "ui_components", None)
+        if ui_components is not None and getattr(ui_components, "timeline", None) is not None:
+            timeline = getattr(ui_components, "timeline", None)
+            timeline_widget = getattr(timeline, "timeline_widget", None) if timeline else None
+            if timeline_widget:
+                for i in range(timeline_widget.count()):
+                    tab = timeline_widget.widget(i)
+                    if tab and tab.property("pulse_animation"):
+                        pulse_anim = tab.property("pulse_animation")
+                        pulse_anim.stop()
+                        pulse_anim.deleteLater()
+
+        # Stop any running toast notifications
+        for child in self.findChildren(QWidget):
+            if isinstance(child, QWidget) and child.property("is_toast"):
+                child.close()
+                child.deleteLater()
+
+        # Call parent close event with error handling
+        try:
+            super().closeEvent(event)
+        except RuntimeError as e:
+            # Handle case where parent resources are already deleted
+            if "already deleted" in str(e):
+                # Resources already cleaned up, just accept the event
+                event.accept()
+            else:
+                # Re-raise other runtime errors
+                raise

-        Args:
-            enabled: Whether to enable auto-centering
-        """
-        # Store the centering state
-        self.auto_center_enabled = enabled
+    def eventFilter(self, watched: object, event: object) -> bool:
+        """Enhanced event filter with hover animations."""
+        # Handle button hover animations
+        if isinstance(watched, QPushButton) and watched.property("enhanced"):
+            if event.type() == event.Type.Enter:
+                self._animate_button_hover(watched, True)
+            elif event.type() == event.Type.Leave:
+                self._animate_button_hover(watched, False)
+
+        # Call parent event filter
+        return super().eventFilter(watched, event)
+
+    def _animate_button_hover(self, button: QPushButton, hovering: bool):
+        """Animate button on hover with opacity effect."""
+        if not self.animations_enabled:
+            return

-        # Update the curve widget if available
-        # curve_widget is Optional
-        if self.curve_widget is not None:
-            if getattr(self.curve_widget, "set_auto_center", None) is not None:
-                self.curve_widget.set_auto_center(enabled)  # pyright: ignore[reportAttributeAccessIssue]
+        # Get or create animation objects
+        anim_id = f"hover_anim_{id(button)}"
+        effect_id = f"opacity_effect_{id(button)}"
+
+        # _button_animations already initialized in __init__
+
+        if anim_id not in self._button_animations:
+            # Use AnimationFactory for consistent animation creation
+            opacity_effect, anim = AnimationFactory.create_opacity_animation(
+                button,
+                duration="fast",
+                start_value=0.9,
+                end_value=1.0,
+                easing=QEasingCurve.Type.OutCubic,
+            )
+            opacity_effect.setOpacity(0.9)  # Set initial opacity
+
+            # Store in our dictionary instead of as widget properties
+            self._button_animations[anim_id] = anim
+            self._button_animations[effect_id] = opacity_effect
+
+        # Get animation and effect from our storage
+        anim = self._button_animations[anim_id]
+        opacity_effect = self._button_animations[effect_id]
+
+        # Stop any running animation
+        if anim.state() == QPropertyAnimation.State.Running:
+            anim.stop()
+
+        if hovering:
+            # Brighten button on hover
+            anim.setStartValue(opacity_effect.opacity())
+            anim.setEndValue(1.0)
+
+            # Also update style for visual feedback
+            current_style = button.styleSheet()
+            if "background-color" not in current_style:
+                button.setStyleSheet(
+                    current_style
+                    + """
+                    QPushButton {
+                        background-color: rgba(255, 255, 255, 0.1);
+                    }
+                """
+                )
+        else:
+            # Return to normal opacity
+            anim.setStartValue(opacity_effect.opacity())
+            anim.setEndValue(0.9)
+
+            # Remove hover style
+            current_style = button.styleSheet()
+            button.setStyleSheet(current_style.replace("background-color: rgba(255, 255, 255, 0.1);", ""))
+
+        anim.start()
+
+    # Override file operations to show loading indicators
+    def _on_action_open(self):
+        """Enhanced open file action with loading indicator."""
+        self.loading_spinner.start()
+        super()._on_action_open()
+        self.loading_spinner.stop()

-        # Log the state change
-        logger.info(f"Auto-centering {'enabled' if enabled else 'disabled'}")
+    @Slot(int, str)
+    def _on_file_load_progress(self, progress: int, message: str):
+        """Enhanced file loading progress display."""
+        # WORKAROUND: Check thread context
+        from functools import partial
+
+        from PySide6.QtCore import QThread, QTimer
+        from PySide6.QtWidgets import QApplication
+
+        current_thread = QThread.currentThread()
+        main_thread = QApplication.instance().thread() if QApplication.instance() else None
+
+        if current_thread != main_thread:
+            logger.debug("[WORKAROUND] _on_file_load_progress rescheduling to main thread")
+            QTimer.singleShot(0, partial(self._on_file_load_progress_impl, progress, message))
+            return

-        # Update status bar
-        # statusBar() is a QMainWindow method, always available
-        self.statusBar().showMessage(f"Auto-center on frame change: {'ON' if enabled else 'OFF'}", 3000)
-
-    def apply_smooth_operation(self) -> None:
-        """Apply smoothing operation to selected points in the curve."""
-        self.interaction_controller.apply_smoothing()
+        self._on_file_load_progress_impl(progress, message)

-    def keyPressEvent(self, event: QKeyEvent) -> None:
-        """Handle key press events for custom shortcuts."""
-        # Tab key toggles tracking panel dock visibility
-        if event.key() == Qt.Key.Key_Tab:
-            self.interaction_controller.toggle_panel_visibility()
-            event.accept()
-            return
+    def _on_file_load_progress_impl(self, progress: int, message: str):
+        """Actual implementation of progress handler."""
+        super()._on_file_load_progress(progress, message)
+
+        # Show modern progress bar (with defensive check)
+        if self.progress_bar_modern is not None:
+            if progress == 0:
+                self.progress_bar_modern.show()

-        # Pass to parent for default handling
-        super().keyPressEvent(event)
+            self.progress_bar_modern.setValue(progress)
+            self.progress_bar_modern.setText(message)

-    def _load_initial_data_file(self) -> None:
-        """Load the initial data file specified via command line."""
-        self.data_controller.load_initial_data_file(self._initial_data_file)
-
-    def set_tracked_data_atomic(self, tracked_data: dict[str, list[tuple[int, float, float]]], active_points: list[str] | None = None) -> None:
-        """Thread-safe method to update tracked data and active points atomically."""
-        self.state_manager.set_tracked_data_atomic(tracked_data, active_points)
-        # Also update local references for compatibility
-        self.tracked_data = self.state_manager.tracked_data
-        self.active_points = self.state_manager.active_points
-
-    def set_file_loading_state(self, is_loading: bool) -> None:
-        """Thread-safe method to update file loading state."""
-        self.state_manager.set_file_loading_state(is_loading)
-
-    def get_file_loading_state(self) -> bool:
-        """Thread-safe method to check file loading state."""
-        return self.state_manager.get_file_loading_state()
+            if progress >= 100:
+                QTimer.singleShot(1000, self.progress_bar_modern.hide)

-    def closeEvent(self, event: QEvent) -> None:
-        """Handle window close event with proper thread cleanup."""
-        logger.info("[PYTHON-THREAD] Application closing, stopping Python thread if running")
+    @Slot()
+    def _on_file_load_finished(self):
+        """Enhanced file loading completion."""
+        # WORKAROUND: PySide6 inheritance bug - overridden slots don't respect QueuedConnection
+        # Check if we're in the main thread
+        from PySide6.QtCore import QThread, QTimer
+        from PySide6.QtWidgets import QApplication
+
+        current_thread = QThread.currentThread()
+        main_thread = QApplication.instance().thread() if QApplication.instance() else None
+
+        if current_thread != main_thread:
+            # We're in the wrong thread - use QTimer.singleShot to run in main thread
+            logger.info("[WORKAROUND] _on_file_load_finished called from worker thread, rescheduling to main thread")
+            QTimer.singleShot(0, self._on_file_load_finished_impl)
+            return

-        # Save session before closing
-        if self.data_controller is not None:
-            self.data_controller.save_current_session()
+        # We're in the main thread - proceed with actual implementation
+        self._on_file_load_finished_impl()

-        # Stop playback timer
-        if self.playback_timer is not None:
-            self.playback_timer.stop()
+    def _on_file_load_finished_impl(self):
+        """Actual implementation of file load finished handler."""
+        logger.info("[WORKAROUND] _on_file_load_finished_impl executing in main thread")
+
+        # Hide loading indicators
+        if self.loading_spinner is not None:
+            self.loading_spinner.stop()
+        if self.progress_bar_modern is not None:
+            self.progress_bar_modern.hide()

-        # Stop the worker thread
-        if self.file_load_worker is not None:
-            self.file_load_worker.stop()
+        # Show success notification
+        self._show_notification("Files loaded successfully!", "success")

-        logger.info("[KEEP-ALIVE] Worker and thread cleaned up")
+    @Slot(str)
+    def _on_file_load_error(self, error_message: str):
+        """Enhanced error handling with notifications."""
+        # WORKAROUND: Check thread context
+        from functools import partial
+
+        from PySide6.QtCore import QThread, QTimer
+        from PySide6.QtWidgets import QApplication
+
+        current_thread = QThread.currentThread()
+        main_thread = QApplication.instance().thread() if QApplication.instance() else None
+
+        if current_thread != main_thread:
+            logger.info("[WORKAROUND] _on_file_load_error rescheduling to main thread")
+            QTimer.singleShot(0, partial(self._on_file_load_error_impl, error_message))
+            return

-        # Accept the close event
-        event.accept()
-        logger.info("MainWindow closed with proper cleanup")
+        self._on_file_load_error_impl(error_message)

+    def _on_file_load_error_impl(self, error_message: str):
+        """Actual implementation of error handler."""
+        super()._on_file_load_error(error_message)
+
+        # Hide loading indicators
+        if self.loading_spinner is not None:
+            self.loading_spinner.stop()
+        if self.progress_bar_modern is not None:
+            self.progress_bar_modern.hide()

-if __name__ == "__main__":
-    app = QApplication(sys.argv)
-    window = MainWindow()
-    window.show()
-    sys.exit(app.exec())
+        # Show error notification
+        self._show_notification(f"Error: {error_message}", "error", 5000)
